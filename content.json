{"pages":[{"title":"404","text":"","path":"404/index.html","date":"01-13","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"01-13","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"01-13","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"01-13","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"01-13","excerpt":""}],"posts":[{"title":"轻松搭建webpack项目简单版","text":"在终端中1.在本次项目搭建过程中我们将主要使用：yarn 这种方式。所以首先我们需要下载yarn. npm i -g yarn 2.下载好yarn后，我们将新建一个文件夹 mkdir 文件夹名 3.cd到这个文件夹 4.初始化文件夹： yarn init -y 5.建一个src文件夹，并进入该文件夹内，建一个入口文件index.js，建好后退回到该文件夹 mkdir srccd srctouch index.jscd .. 6.安装webpack，将其添加到开发依赖中 yarn add webpack —dev 7.全局安装webpack npm i -g webpack 8.创建一个webpack.config.js touch webpack.config.js 在文件中此时我们在终端中的操作就可以告一段落了，下面我们打开这个文件 1.首先我们先在webpack.config.js中进行基本的配置，打开该文件 const path = require(&quot;path&quot;); module.exports = { // 入口文件 entry: &quot;./src/index.js&quot;, // 出口文件 output: { path: path.join(__dirname, &quot;dist&quot;), filename: &quot;build.js&quot; } } 现在我们可以在终端执行一下 webpack。2.接下来我们打开src下的index.js文件，进行一下配置： import React from &quot;react&quot;; import ReactDOM from &quot;react-dom&quot;; ReactDOM.render( &lt;div&gt; &lt;h1&gt;Hello,World&lt;/h1&gt; &lt;/div&gt;, document.getElementById(&quot;root&quot;) ) 然后我们在终端安装一下： yarn add react react-dom 3.然后我们需要配置一下webpack,在output下： module: { loaders: [ { // 处理js文件 // test 匹配所有js文件 test: /\\.js$/, // 使用 loader loader: &quot;babel-loader&quot;, // 除 node_modules 文件之外 exclude: /node_modules/ } } 下载babel： yarn add @babel/preset-react @babel/preset-env @babel/core babel-loader@8.0.0-beta.0 –dev 4.新建一个文件：.babelrc,然后我们来配置一下： { &quot;presets&quot;: [ &quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot; ] } 5.新建一个index.html来测试一下，我们会在网页上看到Hello，World的效果 6.接下来我们需要下一些插件，让他可以自动引入，首先，我们在webpack.config.js中继续配置 ，如： plugins: [ new HTMLWebpackPlugin({ //例如： template: &quot;./index.html&quot;, filename: &quot;index.html&quot;, title: &quot;首页&quot;, inject: &quot;body&quot; }) ] 配置完成后，下载： yarn add html-webpack-plugin –dev 下载完成后，在文件中引入： const HTMLWebpackPlugin = require(“html-webpack-plugin”); 7.启动服务 yarn add webpack-dev-server&nbsp;—dev 8.在package.json中修改 &quot;license&quot;: &quot;MIT&quot;, // 在此处修改 &quot;scripts&quot;: { &quot;start&quot;: &quot;webpack-dev-server&quot; }, 9.最后我们就可以使用 yarn start启动服务了。 另外如果你想要引入css和img的话，你只需要在终端下载： yarn add css-loader style-loader –devyarn add url-loader 下载完成后，在webpack.config.js中配置： { test: /\\.css$/, loader: [ &quot;style-loader&quot;, &quot;css-loader&quot;, ], exclude: /node_modules/ }, { test: /\\.png|\\.jpg|\\.svg|\\.jpeg$/, loader: &quot;url-loader&quot;, exclude: /node_modules/ }, 然后再在index.js中引入即可。","path":"2018/02/07/轻松搭建webpack项目简单版/","date":"02-07","excerpt":""},{"title":"CSS3新特性，伪类，伪元素，锚伪类","text":"CSS3新特性，伪类，伪元素，锚伪类CSS3新特性1.CSS3的选择器 1）p:last-child 匹配父元素的最后一个子元素p 2）p:nth-child(n)匹配父元素的第n个子元素p 3）p:nth-last-child(n) CSS3 匹配父元素的倒数第n个子元素p2.@Font-face 特性 Font-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。@font-face { font-family: BorderWeb; src:url(BORDERW0.eot); }@font-face { font-family: Runic; src:url(RUNICMT0.eot);}.border { FONT-SIZE: 35px; COLOR: black; FONT-FAMILY: “BorderWeb” }.event { FONT-SIZE: 110px; COLOR: black; FONT-FAMILY: “Runic” }3.圆角 4.多列布局 （multi-column layout）：兼容性不好，还不够成熟。还不能用在实际项目中。 5.阴影 6.CSS3 的渐变效果 7.css弹性盒子模型 8.CSS3制作特效 s1）Transition 对象变换时的过渡效果 transition-property 对象参与过渡的属性 transition-duration 过渡的持续时间 transition-timing-function 过渡的类型 transition-delay 延迟过渡的时间 2) Transforms 2D转换效果 translate（水平移动）、rotate（旋转）、scale（伸缩）、skew（倾斜） 3) Animation动画特效 参照：http://blog.csdn.net/lxcao/article/details/52797914以及：http://blog.csdn.net/chandoudeyuyi/article/details/69206236 伪类与伪元素1）.伪类:2）.伪元素：CSS伪元素：用于将特殊的效果添加到某些选择器。伪元素代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。 伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。 3）新增伪类 锚伪类a:link{color:#ff00ff} 表示未访问的链接 a:visited{color:#00ff00} 表示已访问的链接 a:hover{color:#ff00ff} 鼠标移动到链接上的情况 a:active{colot:#0000ff} 表示选定的链接 注意：a:hover必须放在a:link和a:visited之后，a:active必须放在a:hover之后 参照：http://blog.csdn.net/zhouziyu2011/article/details/58605705","path":"2018/02/03/CSS3新特性，伪类，伪元素，锚伪类/","date":"02-03","excerpt":""},{"title":"有关React的一些基础知识总结","text":"有关React的一些基础知识总结1.什么是属性？什么是状态？（1） ·····属性的定义····· 属性不可以修改，也就是属性不可以由组件进行修改，组件的属性是由父组件传递过来的，相当于组件在出生的时候带的。 ·····属性的用法······&lt;Welcome name=&quot;Sara&quot; /&gt;;&lt;Welcome name = {Sara} /&gt;&lt;Welcome name = {“Sara”} /&gt;&lt;Welcome name = {[1,2,3]} /&gt; 数组&lt;Welcome name = {Function} /&gt; 函数或者： var props = { one :”123”, tow :321}&lt;ClassNameB {…props} /&gt; 增加三个引号相当于这里面拿到两个属性了（one和two） （2） ·····状态的定义······ 状态：使用 this.state 和 this.setState。状态是事物自己处理的，不和属性一样，属性是天生的，事物一般来说没有办法修改。状态是事物本身的是事物的私有属性，也就是由自己决定，父组件和子组件都不能改变他。给定了状态就一定知道结果是什么。状态与属性十分相似，但是状态是私有的，完全受控于当前组件 。 （3） ······属性和状态的相同点······ 1.都是纯js对象2.都会触发render函数更新3.都具有确定性：状态相同，结果一定相同，这就是确定性。给定了相同的属性或者相同的状态，结果都是一样的。 （4） ······如何区分属性和状态····· 组件在运行时需要修改的数据就是状态。属性的核心要点就是不能修改！根本的区别：组件在运行时需要去修改维护的就是状态 参照：https://www.cnblogs.com/Gabriel-Wei/p/6111822.html 2.什么是元素？什么是组件（1） ·····元素的定义····· 元素是构成 React 应用的最小单位，用来描述你在屏幕上看到的内容。元素事实上只是构成组件的一个部分。 ·····元素的用法······ React 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象（plain objects），所以也没办法直接调用 DOM 原生的 API。只有在这个元素渲染被完成后，才能通过选择器的方式获取它对应的 DOM 元素。如： const element = &lt;h1&gt;Hello, world&lt;/h1&gt;; 当React遇到的元素是用户自定义的组件，它会将JSX属性作为单个对象传递给该组件,这个对象称之为“props”。如： function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;} const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;ReactDOM.render( element, document.getElementById(‘root’)); ·····组件的定义····· 组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。 ·····组件的用法······定义一个组件最简单的方式是使用JavaScript函数： function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;} 也可以使用 ES6 class 来定义一个组件: class Welcome extends React.Component { render() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } } 参考：http://blog.csdn.net/sinat_37924453/article/details/78138268 3.组件分为哪几种类型？·····React组件的两个重要特性：······ 1.props:组件属性，专门用来连接父子组件间通信，父组件传输父类成员，子组件可以利用但不能编辑父类成员；2.state：专门负责保存和改变组件内部的状态； 类型一：无状态组件 无状态组件(Stateless Component)是最基础的组件形式，由于没有状态的影响所以就是纯静态展示的作用。一般来说，各种UI库里也是最开始会开发的组件类别。如按钮、标签、输入框等。它的基本组成结构就是属性（props）加上一个渲染函数（render）。 const PureComponent = (props) =&gt; ( &lt;div&gt; //use props &lt;/div&gt; ) 类型二：有状态组件 如果组件内部包含状态（state）且状态随着事件或者外部的消息而发生改变的时候，这就构成了有状态组件（Stateful Component）。有状态组件通常会带有生命周期(lifecycle)，用以在不同的时刻触发状态的更新。这种组件也是通常在写业务逻辑中最经常使用到的。 // 使用状态 实现时钟 class Time extends React.Component{ // 构造器函数，初始化 constructor(props) { super(props); // 初始化状态 this.state = { date: new Date() } // 每隔一秒 修改状态 setInterval(()=&gt;{ console.log(&quot;定时器执行&quot;) // 赋值，修改 this.setState({ date:new Date() }) },1000) } render(){ console.log(&quot;时间&quot;+this.state.date) return ( &lt;p&gt;当前时间：{this.state.date.toLocaleTimeString()}&lt;/p&gt; ) } } ReactDOM.render( &lt;Time /&gt;, document.getElementById(&quot;root&quot;) ) 类型三：容器组件 在具体的项目实践中，我们通常的前端数据都是通过Ajax请求获取的，而且获取的后端数据也需要进一步的做处理。为了使组件的职责更加单一，引入了容器组件(Container Component)的概念。我们将数据获取以及处理的逻辑放在容器组件中，使得组件的耦合性进一步地降低。 var UserListContainer = React.createClass({ getInitialState: function() { return { users: [] } }, componentDidMount: function() { var _this = this; axios.get(&apos;/path/to/user-api&apos;).then(function(response) { _this.setState({users: response.data}); }); }, render: function() { return (&lt;UserList users={this.state.users} /&gt;); } }); 参考：https://juejin.im/post/596d65d66fb9a06bae1e19e2","path":"2018/01/30/有关React的一些基础知识总结/","date":"01-30","excerpt":""},{"title":"有关js的比较好的面试题","text":"有关js的比较好的面试题1.什么是JavaScript？ 答：JavaScript是客户端和服务器端脚本语言，可以插入到HTML页面中，并且是目前较热门的Web开发语言。同时，JavaScript也是面向对象编程语言。 2.什么是全局变量？这些变量如何声明，使用全局变量有哪些问题？ 答：全局变量是整个代码长度可用的变量，也就是说这些变量没有任何作用域。var关键字用于声明局部变量或对象。如果省略var关键字，则声明一个全局变量。 使用全局变量所面临的问题是本地和全局变量名称的冲突。此外，很难调试和测试依赖于全局变量的代码。 3.如果有这样一段代码，他最后的运行结果是什么? for (var i = 0; i &lt; 5; i++) { setTimeout(function() { console.log(new Date, i); }, 1000);}console.log(new Date, i); 实际运行结果为：5,5,5,5,5,5；这是由于：JS 中同步和异步代码的区别、变量作用域、闭包等概念产生的 4.接着，如果我们约定，用箭头表示其前后的两次输出之间有 1 秒的时间间隔，而逗号表示其前后的两次输出之间的时间间隔可以忽略，代码实际运行的结果该如何描述？ 答：5 -&gt; 5,5,5,5,5 即第 1 个 5 直接输出，1 秒之后，输出 5 个 5；这是因为：循环执行过程中，几乎同时设置了 5 个定时器，一般情况下，这些定时器都会在 1 秒之后触发，而循环完的输出是立即执行的 5.如果你以为到这里就结束了的话，那你就太天真了。新的问题来了，如果期望代码的输出变成：5 -&gt; 0,1,2,3,4，该怎么改造代码？ for (var i = 0; i &lt; 5; i++) { (function(j) { // j = i setTimeout(function() { console.log(new Date, j); }, 1000); })(i);}console.log(new Date, i); 或者： var output = function (i) { setTimeout(function() { console.log(new Date, i); }, 1000);};for (var i = 0; i &lt; 5; i++) { output(i); // 这里传过去的 i 值被复制了}console.log(new Date, i); 6.在增加一点难度：如果期望代码的输出变成 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5，并且要求原有的代码块中的循环和两处 console.log 不变，该怎么改造代码？新的需求可以精确的描述为：代码执行时，立即输出 0，之后每隔 1 秒依次输出 1,2,3,4，循环结束后在大概第 5 秒的时候输出 5。那么我们就可以使用Promise来解决这个问题（Promise 是 ES6 中的新特性） const tasks = []; // 这里存放异步操作的 Promiseconst output = (i) =&gt; new Promise((resolve) =&gt; { setTimeout(() =&gt; { console.log(new Date, i); resolve(); }, 1000 * i);}); // 生成全部的异步操作for (var i = 0; i &lt; 5; i++) { tasks.push(output(i));} // 异步操作完成之后，输出最后的 iPromise.all(tasks).then(() =&gt; { setTimeout(() =&gt; { console.log(new Date, i); }, 1000);}); 参考来源：王仕军 –https://juejin.im/post/58cf180b0ce4630057d6727c","path":"2018/01/27/有关js的比较好的面试题/","date":"01-27","excerpt":""},{"title":"浅谈css的三种预处理器--Less，Sass以及Stylus","text":"浅谈css的三种预处理器–Less，Sass以及Stylus写在前面： 问：css本身可以写样式，但是为什么还会出现css的预处理器呢? 答：就CSS本身而言，它不是一种编程语言。也就是说，我们用它来对网页的开发是没有问题的，但是我们却不能用它来编程。由此，神通广大的程序员们就开始想办法了。~~~~我们要让css像其他程序语言一样！！我们也要编程！！于是。。。就产生了一个预处理器，两个预处理器，三个预处理器😂 甚至更多。 css预处理器的好处 css预处理器其实就是为css设计了一套属于自己的衣服，让他也能有像其他编程语言一样的特异功能。当我们预处理完成后在把他编译成正常的css文件。这样做的好处是当我们使用了预处理器后，我们在编写样式的时候会更加的方便，代码的可读性也会更高，当然，我们写的代码也就更容易维护了。 对于Less，Sass以及Stylus预处理器的历史简介1.sass Sass是对CSS的语法的一种扩充，诞生于2007年，最早也是最成熟的一款CSS预处理器语言，它可以使用变量、常量、嵌套、混入、函数等功能，可以更有效有弹性的写出CSS。 sass中文网：https://www.sass.hk/ 2.less LESS由Alexis Sellier于2009年设计。它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，LESS 可以让我们用更少的代码做更多的事情。 less中文网：http://lesscss.cn/ 3.stylus Stylus，2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持。Stylus 是一种新型语言，可以创建健壮的、动态的、富有表现力的CSS。比较年轻，其本质上做的事情与 SASS/LESS 等类似。 stylus官网：http://stylus-lang.com/ 那么，我们选择哪种预处理器更好呢为了解决这个问题，我们应该先使用对比一下。所以，首先我们来下载这三种预处理器 1.sass下载方法： gem install sass 如果是Mac的话可能会遇到这样的问题： ERROR: While executing gem … (Gem::FilePermissionError)You don’t have write permissions for the /Library/Ruby/Gems/2.0.0 directory. 这是因为没有管理员权限.png ,所以执行： sudo gem install sass 然后输入密码就可以了 2.less下载方法： npm i -g less 3.stylus下载方法： npm i -g stylus 如上所述，我们只需要简单的通过npm安装一下就可以使用了。由于现在主要是为了对他们进行学习，所以我们可以利用webstorm提供的功能来快速的将我们写的样式编译成css文件。如：我们只需要直接点击yes就可以了。 另外，需要注意的是，对于这三种处理器的后缀名是有自己的要求的。其中less文件的后缀为.less; stylus的后缀名为.styl；而sass则有些特殊了，sass有两种后缀名文件：一种后缀名为.sass，不使用大括号和分号；另一种为.scss的文件，这种和我们平时写的css文件格式差不多，使用大括号和分号。 那么，废话不多说，当我们做好这些准备工作后，就可以开始尝试着用一下了。 使用方法eg：让我们一起看看以下几个例子： 一.嵌套 less： .all{ width: @w; height: @h; border: 1px solid skyblue; header{ width: 100px; height: 100px; background-color: gold; p{ font-size: 50px; } :nth-child(2){ color: aqua; } } } 而在stylus 和 sass中： .div1 .p1 background-color: red width: 150px height: 150px 也就是说，三者的嵌套语法都是一致的，甚至连引用父级选择器的标记 &amp; 也相同。区别只是 Sass 和 Stylus 可以用没有大括号的方式书写。 二.变量 对于在预处理器中使用变量的定义方式无疑是革命性的进步。它为CSS 增加了一种有效的复用方式，减少了原来在 CSS 中无法避免的重复「硬编码」。在这三种预处理器中我们都可以使用变量的方式，作用也基本都相同，只是在定义是会用少许不同。如： less： @red: red;strong { color: @red;} stylus： red = redstrong color: red sass： $red: red;strong { color: $red;} 三.继承less： .div1(@num:100px; @color2:pink){ width: @num; height: @num; background-color: @color2;}.box{ .div1(); border-radius: 50%;} 这种方法的缺点就是在每个选择器中会有重复的样式产生。 而stylus &amp;&amp; sass .div1 { margin: 10px 5px; padding: 2px;}p { @extend .div1; border: 1px solid #eee;}ul,ol { @extend .div1; color: #333;} Sass和Stylus的继承是把一个选择器的所有样式继承到另个选择器上。在继承另个选择器的样式时需要使用“@extend”。 这三种预处理器中还支持赋值以及判断等等功能，喜欢的小伙伴可以自行到他们的官网上进行研究，在这里就不多说了。 经过对这三种预处理器简短的尝试之后，我觉得自己还是更加喜欢 less 一点，毕竟这和我们平时写css时的规则很相像。对于初换处理器的我来说更加容易上手。而sass 和 stylus 对于我来说他的改变太过于激进，接受起来稍微有些不太适应。写多了就会感觉有点乱。最后的最后欢迎大家多多尝试。","path":"2018/01/20/浅谈css的三种预处理器-Less，Sass以及Stylus/","date":"01-20","excerpt":""},{"title":"使用hexo和GitHub轻松搭建自己的博客","text":"#使用hexo和GitHub轻松搭建属于自己的博客 关于搭建博客的那点事：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从来都没想过搭建一个自己的博客，在学前端之前甚至连博客是什么都不知道。但是随着学习的深入，接触的东西也越来越多，慢慢发现对于自己学习的检验不只要体现在每天敲代码上，也该有一个类似于笔记的东西来整理自己的心得，所以上网左翻右翻，最后发现写一个博客是个不错的方法（因为只有自己能看到的笔记过后再读常常会发现自己以前写的很草率😕 ）。为了鞭策自己最近下决心来打搭一个自己的博客。 那么问题来了，为什么要搭一个自己的博客呢？ 当然是自主权比较高啦如果我们在一些博客平台上建一个自己的博客的话，虽然很方便，省去了自己找资源，自己搭建的过程，但是同样的，我们的博客会受到这些博客平台这样或那样的限制，比如说可能会限制插件的代码使用啦，广告的插入啦，而且对于你的博客内容也会有各种各样的限制（比如说涉及到政治上，黄赌毒。。。之类的内容。😝 当然，自建博客最好也别和这些沾边。）😝 好啦，不多说了，了解了建博客的好处之后我们就可以开始着手搭建了，接下来就是搭建博客应该做的准备工作了。 准备工作开始&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ps：因为本人现在使用的是苹果机，所以这篇博客将会以 Mac 来作为参考，但是我也在网上看了些有关针对于windows来搭建博客的方法，与mac搭建方法差不多，由于我没有windows的电脑，没有办法看到图片，所以用windows的小伙伴只能自己上网找找了。 1.首先，我们要注册一个Github账号,点击这里：https://github.com/ 可以进入GitHub官网开始注册。2.当我们注册完成后，就可以开始建库了。 如下图所示： 找到 Start a project ,点击建库： 在创建仓库名字的时候一定要输入： 你自己的:Github昵称.github.io 然后点击Create repository创建就可以了。 3.生成秘钥在终端输入： ssh-keygen -t rsa -C “Github的注册邮箱地址” &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时会出现很多东西，但是你只需要一直Enter就好，等到秘钥生成完毕你会得到id_rsa和 id_rsa.pub 这两个文件。你需要找到放置这两个文件的地方，然后用记事本打开 id_rsa.pub,复制里面所有的内容，然后点击进入https://github.com/settings/ssh/new： 如下图所示： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随便写一个Title的题目，然后把刚刚复制的内容粘贴到Key中，点击 Add SSH key 创建秘钥。 ps：id_rsa是私钥，id_rsa.pub是公钥。 4.安装node.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于如何安装nodejs在这里我就不多说了，如果大家的电脑里没有可以到node.js官网上下载。 5.安装git对于git的安装也很简单，如果没有git的可自行网上查阅 进入正题准备工作做好后，我们开始准备安装配置hexo了 1.建一个文件夹，用来放置你的博客2.在终端中：cd 文件夹 3.下载安装hexonpm install -g hexo-cli 4.完成后输入：hexo 如上图所示：你已经安装hexo成功了 5.建立一个文件夹，随便起名字，如:myHexo。初始化博客hexo init myHexo 6.进入文件夹cd myHexo 7.安装依赖包npm install 8.找到文件中的_config.yml文件，接下来我们将对他进行一些修改注意：对于以下我们每一项的修改，在 : 的后面都一定要留一个空格，不然在接下来的执行中会报错,eg： title: inerdstack✅ title:inerdstack ❎ 打开文件，找到开头: Site 部分，修改为： title: inerdstacksubtitle: the stack of it nerdsdescription: start from zeroauthor: inerdstacklanguage: zh-CNtimezone: Asia/Shanghai 找到 URL 部分，修改为： url: http://自己的域名 找到最下方 Deployment 部分，修改为： deploy: type: git repo: https://github.com/Xqqqqqq/Xqqqqqq.github.io.git branch: master 如下图所示：（这里为什么要配张图呢，是因为小编实在没有排好版啊~~(&gt;_&lt;)~~） 之后保存并关闭就好啦。 接下来我们就可以测试一下试试啦在终端输入：hexo new &quot;文章标题&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时我们第一篇文章的标题就建好了，我们可以在博客文件夹中的_post看到我们刚刚所建的文件标题，用markdown编辑器打开就可以开始编辑了。现在你可以随便写点内容，保存之后，我们一起来本地测试一下，在终端输入：hexo server 待服务器启动后，打开浏览器输入：http://localhost:4000/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时你就可以看到你刚刚编辑的文章了，怎么样，成功了吧 ☺️ 。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你以为到这里就都结束了么？那你就错了！我们现在还有一个更艰巨的任务========选择一个好看的主题😋 哈哈哈~~~~ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家可以根据自己的喜好选择自己喜欢的图片，这里推荐一下这个网址https://hexo.io/themes/,小编正在使用的就是其中的这个主题：http://sora3.coding.me/（强烈安利！！！！因为这个主题实在太好玩了，小编对它爱不释手 😝😝😝 ）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈哈。好了这次的内容大概就这么多了，祝大家玩的开心，写的开心。","path":"2018/01/13/使用hexo和GitHub轻松搭建属于自己的博客/","date":"01-13","excerpt":""},{"title":"文章标题","text":"你好，欢迎来到我的个人技术博客","path":"2018/01/12/文章标题/","date":"01-12","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/01/12/hello-world/","date":"01-12","excerpt":""}]}